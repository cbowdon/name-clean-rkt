#lang racket
(require "name-clean-rules.rkt")

(provide handle-input
         get-new-path
         split-path-pair
         cmd-args)

(define rules (get-rules test-file))

; process command-line arguments
(define (cmd-args)
  (handle-input (map string->path 
                     (vector->list (current-command-line-arguments)))))

; decide return flat list of file paths
(define (handle-input input)
  (flatten (cond ((list? input) (map handle-input input)) 
                 ((file-exists? input) input)
                 ((directory-exists? input) (handle-directory input))
                 (else (error "Not a file, list of files or directory:" input)))))

; handle directory
(define (handle-directory d)
  (map handle-input
       (map (lambda (x) (build-path d x)) 
            (directory-list d))))

; wrap the built-in split-path more neatly
(define (split-path-pair x)
  (let-values (((path filename bool) (split-path x)))
    (cons path filename)))
  
  ; get new path 
  (define (get-new-path file)
    (let-values (((path name bool) (split-path file)))
      (let ((new-name (get-new-name name)))
        (if (eq? path 'relative)
            new-name
            (build-path path new-name)))))
  
  ; get new filename (no path)
  (define (get-new-name arg)
    (let ((name (path->string (path-replace-suffix arg "")))
          (ext (string-append "." (bytes->string/utf-8 (filename-extension arg)))))
      (string->path (string-append (apply-rules name rules) ext))))