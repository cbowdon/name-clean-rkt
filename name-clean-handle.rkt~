#lang racket
(require "name-clean-rules.rkt")

(provide handle-input
         get-new-path
         split-path-list
         split-path-pair)

(define rules (get-rules test-file))

; return flat list of (delay-cons old-path new-path)
(define (handle-input input)
  (flatten (cond [(list? input) (map handle-input input)] 
                 [(file-exists? input) input]
                 [(directory-exists? input) (handle-directory input)]
                 [else (error "Not a file, list of files or directory:" input)])))

; handle directory
(define (handle-directory d)
  (map handle-input
       (map (lambda (x) (build-path d x)) 
            (directory-list d))))

; split paths into (directory name extension)
(define (split-path-list x)
  (let-values ([(dir filename bool) (split-path x)])
    (let ([name (path-replace-suffix filename "")]
          [ext (get-ext-string filename)])
      (if (equal? (path->string filename) ext)
          (list dir filename "")
          (list dir name ext)))))

; split paths into (directory name.ext)
(define (split-path-pair x)
  (let-values ([(dir filename bool) (split-path x)])
    (cons dir filename)))


; filename-extension modified to append the "."
(define (get-ext-string x)
  (if (not (filename-extension x))
      ""
      (string-append "." (bytes->string/utf-8 (filename-extension x)))))


; get new path 
(define (get-new-path old-path)
  (let* ([spl (split-path-list old-path)]
         [new-name-string (apply-rules (path->string (cadr spl)) rules)])
    (cond [(eq? (car spl) 'relative) (string->path (string-append new-name-string (caddr spl)))]
          [else (build-path (car spl) (string->path (string-append new-name-string (caddr spl))))])))

